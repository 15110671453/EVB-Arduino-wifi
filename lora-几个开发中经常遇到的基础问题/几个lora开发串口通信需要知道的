串口传输
        传输过程是一位一位的二进制进行传输，传输完一个字节才会产生中断或者事件。
        所以从编程角度上看，是一整个字符进行传输的。
        从物理信号层面看，还是一位一位传输的。 
传输物理层 还是0101一位一位的传  但是编程角度  串口传输够一个字节也就是一个char 就会中断一次 这个传输过来的 使用什么表现形式呢  
        在Arduino与门思的lora模块连接 并usb与mac电脑连接的开发中 发现 lora回传给我们的是16进制表现形式 一个字符
  
那么这里  区别一下 CPU位数、操作系统位数、计算机字长、C/C++基本数据类型长度
      1.CPU位数=CPU中寄存器的位数=CPU能够一次并行处理的数据宽度（位数）=数据总线宽度；
       //现在的计算机处理器一般都是64位，这是硬件的事。

      2.CPU为了实现其功能设计了指令集，即是CPU的全部指令，这是机器语言。计算机的所有功能都是基于CPU的指令集。指令集和CPU的位数是有联系的。如Intel 8086 CPU 是16位，其指令集也是16位。如Intel 80386DX CPU 是32位，其指令集也是32位，但它也保持原16位指令集，这是为了向上兼容。有64位CPU上运行32位操作系统、32位CPU上运行16位操作系统的情况，也是为了向上兼容。

      3.操作系统位数 = 其所依赖的指令集位数 <= CPU位数(64位操作系统 还是 32 位操作系统 和 cpu指令集有关 )

      4.计算机字长（机器字长）取决于数据总线的宽度，通常就是CPU一次能处理的数据的位数（CPU位数）。像平时我们买电脑说的64位的处理器，指的就是字长为64的CPU。至于装32位还是64位的系统，随便。

      5./*以下经WinXP和Win7 64位系统测试，应该跟系统没关系，而是跟CPU位数、或者编译器有关系，我用的是vs2008，我这两台电脑都是64位CPU，所以结果是一样的，但我还是试了试，果然是一样的，同一类型的有符号和无符号长度一样，只不过值的范围不一样*/
      bool=1字节；
     char=1字节；//signed可省略（-2^7~2^7-1），unsigned不可省略（0~2^8-1）
     short=2字节；//指int的short，int可省略，signed可省略（-2^15~2^15-1），unsigned不可省略（0~2^16-1）
      int=4字节；//signed可省略（-2^31~2^31-1），unsigned不可省略（0~2^32-1）
      long=4字节；//指int的long，int可省略，signed可省略（-2^31~2^31-1），unsigned不可省略（0~2^32-1）
      float=4字节；
      double=8字节；
      6.总结：
      在标准c++中，int的定义长度要依靠你的机器的字长，也就是说，如果你的机器是32位的，int的长度为32位，如果你的机器是64位的，那么int的标准长度就是64位，比如16位机上，sizeof(int) = 2，而32位机上sizeof(int) = 4；32位机上sizeof(long) = 4，而64位机上sizeof(long) = 8。
      但是在32位机器和64机器中int类型都占用4个字节，因为一般编译器可以根据自身硬件来选择合适的大小，但是需要满足约束：short和int型至少为16位，long型至少为32位，并且short型长度不能超过int型，而int型不能超过long型。这即是说各个类型的变量长度是由编译器来决定的，而当前主流的编译器中一般是32位机器和64位机器中int型都是4个字节（例如，GCC）。
      
进制 16进制 FF 11 22  这两个表现字母 代表一个字节 因为16 进制与 2进制转换 本来就是
      
      被除数     计算过程     商           余数
      120       120/16      7             8
       7          7/16      0             7
       
       16位整数大小端字节序 对应出来的十进制数值算法：

       十进制 120 对应十六进制 0x78  但是在串口传输过成功 并没有0x修饰符 一个字节一个字节传输给客户机解析
       
       0x11 = 17 ; 0x22 = 34 ; 0x0022 = 34 ;  0x1122 = 4386 ;0x2211 = 8721;
       
       高位 34 x 256 + 17 = 8721
       
       被除数               计算过程        商         余数
        1234               1234/16        77         2
        77                 77/16          4          13(D)
        4                   4/16          0          4   
       0x4D2的二进制形式： 0100 1101 0010。

      其中对映关系为：

      0100 -- 4

      1101 -- D

      0010 -- 2

       32 位整数大小端字节序 对应出来的十进制数值算法：

       0x000033 = 51; 51x256 + 34x256 +17 =
       
       0x112233 = 1122867 3342336 8704 
       以上思路错误

       0x11223344
       大端字节序

       i = (data[3]<<0)|(data[2]<<8)|(data[1]<<16)|(data(0)<<24);

       小端字节序

       i = (data[0]<<0)|(data[1]<<8)|(data[2]<<16)|(data(3)<<24);

      
      十进制中的数位排列是这样的…… 万 千 百 十 个 十分 百分 千分……

      R进制中的数位排列是这样的……R^4 R^3R^2 R^1 R^0 R^-1 R^-2 R^-3……



这里 我们处理 位运算
      ： 位元算 其实 是直接对整数在内存中的二进制位进行操作

      举个例子，6的二进制是110，11的二进制是1011，那么6 and 11的结果就是2

      0110 & 1011 -> 2

与运算   &  and

或运算   |  or

异或运算  ^  xor

取反运算  ~  not

左移运算  <<  shl

右移运算  >>  shr

一个数 and 1的结果就是取二进制的最末位。这可以用来判断一个整数的奇偶，二进制的最末位为0表示该数为偶数，最末位为1表示该数为奇数.

一个数 or 1   
结果就是把二进制最末位强行变成1。
如果需要把二进制最末位变成0，
对这个数
or 1 之后再减一就可以了，其实际意义就是把这个数强行变成最接近的偶数。



常见的二进制位的变换操作。

    功能              |           示例            |    位运算
———————-+—————————+——————–
去掉最后一位          | (101101->10110)           | x shr 1
在最后加一个0         | (101101->1011010)         | x shl 1
在最后加一个1         | (101101->1011011)         | x shl 1+1
把最后一位变成1       | (101100->101101)          | x or 1
把最后一位变成0       | (101101->101100)          | x or 1-1
最后一位取反          | (101101->101100)          | x xor 1
把右数第k位变成1      | (101001->101101,k=3)      | x or (1 shl (k-1))
把右数第k位变成0      | (101101->101001,k=3)      | x and not (1 shl (k-1))
右数第k位取反         | (101001->101101,k=3)      | x xor (1 shl (k-1))
取末三位              | (1101101->101)            | x and 7
取末k位               | (1101101->1101,k=5)       | x and (1 shl k-1)
取右数第k位           | (1101101->1,k=4)          | x shr (k-1) and 1
把末k位变成1          | (101001->101111,k=4)      | x or (1 shl k-1)
末k位取反             | (101001->100110,k=4)      | x xor (1 shl k-1)
把右边连续的1变成0    | (100101111->100100000)    | x and (x+1)
把右起第一个0变成1    | (100101111->100111111)    | x or (x+1)
把右边连续的0变成1    | (11011000->11011111)      | x or (x-1)
取右边连续的1         | (100101111->1111)         | (x xor (x+1)) shr 1
去掉右起第一个1的左边 | (100101000->1000)         | x and (x xor (x-1))


















