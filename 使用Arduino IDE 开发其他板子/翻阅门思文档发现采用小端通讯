翻阅门思文档发现采用小端通讯

数据报文使用小端模式通讯

对于嵌入式工程师来说，不仅要熟悉各种数据类型，还需要熟谙各种数据在内存中的表达形式。软件高手们通过内存与指针微妙的配合，总能摩擦出惊艳的火花。在讨论数据的存储结构时，必然会涉及到大端模式(Big-Endian)和小端模式(Little-Endian)的问题。平时编程时对于这个概念并不会有太多接触，但是在通讯协议的处理、可移植性方面就必须要考虑到字节序的问题。以下就来讨论这个问题。

Big-Endian和Little-Endian的定义如下：
1) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。
2) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。

举一个例子，比如数字0×12 34 56 78在内存中的表示形式为：

程序员的地址 从左往右 低地址 到 高地址

大端模式 低地址 是 低位 高地址 放高位

小端模式 低地址 是 高位 高地址 放低位

1)大端模式：

低地址 ————————> 高地址

0×12 | 0×34 | 0×56 | 0×78

2)小端模式：

低地址 ————————-> 高地址

0×78 | 0×56 | 0×34 | 0×12




二、数组在大端小端情况下的存储：
　　以unsigned int value = 0x12345678为例，分别看看在两种字节序下其存储情况，我们可以用unsigned char buf[4]来表示value：
　　Big-Endian: 低地址存放高位，如下：
高地址
        ---------------
        buf[3] (0x78) -- 低位
        buf[2] (0x56)
        buf[1] (0x34)
        buf[0] (0x12) -- 高位
        ---------------
        低地址
Little-Endian: 低地址存放低位，如下：
高地址
        ---------------
        buf[3] (0x12) -- 高位
        buf[2] (0x34)
        buf[1] (0x56)
        buf[0] (0x78) -- 低位
        --------------
低地址

四、如何判断机器的字节序 

#include <stdio.h>  
int main (void)  
{  
    union  
    {  
        short i;  
        char a[2];  
    }u;  
    u.a[0] = 0x11;  
    u.a[1] = 0x22;  
    printf ("0x%x\n", u.i);  //0x2211 为小端  0x1122 为大端  
    return 0;  
}  
输出结果：  
0x2211  


union 型数据所占的空间等于其最大的成员所占的空间。对 union 型的成员的存取都是相对于该联合体基地址的偏移量为 0 处开始，也就是联合体的访问不论对哪个变量的存取都是从 union 的首地址位置开始。
联合是一个在同一个存储空间里存储不同类型数据的数据类型。这些存储区的地址都是一样的，联合里不同存储区的内存是重叠的，修改了任何一个其他的会受影响。



2. 共用体和结构体的区别
1）共用体和结构体都是由多个不同的数据类型成员组成, 但在任何同一时刻, 共用体只存放了一个被选中的成员, 而结构体的所有成员都存在。
2.）对于共用体的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结构体的不同成员赋值是互不影响的。

总结：
恍然大悟，union 联合之前还是没有理解透。一开始不太理解，为什么给 a[0]、a[1] 赋值，i 没有定义啊，为什么会有值呢，或者值为什么不是随机数呢？现在明白了，我们为什么用 union 联合来测试大小端，在联合变量 u 中, 短整型变量 i 和字符数组 a 共用同一内存位置。给 a[0]、a[1] 赋值后，i  也是从同一内存地址读值的。

#include <stdio.h>  
int main (void)  
{  
    short i = 0x1122;  
    char *a = (char*)(&i);  
    printf ("0x%x\n", *(a + 0)); //大端为 0x11 小端为 0x22  
    printf ("0x%x\n", *(a + 1));  
    return 0;  
}  
输出结果：  
0x22  
0x11  


这里 应该知道 我们通过串口 给的原本是0x1122  但是我们从串口取出来 按照指针取出来 却是 11 22 ，并没有0x  这就是我们要处理的
